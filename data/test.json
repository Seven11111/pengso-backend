{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1746437518586290178",
        "title": "从 0 到 1 实现鸿蒙开发的 Hello World，推开鸿蒙开发的大门",
        "description": "鸿蒙开发入门",
        "content": "<a name=\"DKJOO\"></a>\n\n# 鸿蒙开发入门\n\n作为新手，最建议的教程就是跟着官网一步一步来就可以了，很多人可能有看视频学习的习惯，但是就目前来说，最了解鸿蒙开发的，其实就是华为官方的鸿蒙开发，所以编写的文档最权威的还是华为官方的文档，这里我就只是抛砖引玉而已，更详细的文档还是需要各位观看官方文档进行学习，这里链接全都放在下面了，需要的同学自取即可。\n<a name=\"T9AA5\"></a>\n\n## HarmonyOS 官方文档链接\n\n[开发者文档|HarmonyOS应用开发官网](https://developer.harmonyos.com/cn/documentation/overview/?catalogVersion=V3)<br />[鸿蒙开发者文档](https://developer.harmonyos.com/cn/documentation/overview/?catalogVersion=V3)\n\n<a name=\"ZAqcG\"></a>\n\n## 鸿蒙开发工具 DevEco Studio\n\n然后关于鸿蒙开发，其开发的主要工具是  DevEco Studio 编辑器，其下载链接以及下载文档如下，需要的同学自行下载即可，然后关于视频教程的话，可以观看黑马在于 B 站的教程，这里全都放到下面了，只要照着下载即可\n\n1. 下载链接：[https://developer.harmonyos.com/cn/develop/deveco-studio#download](https://developer.harmonyos.com/cn/develop/deveco-studio#download) \n   - Windows(64-bit)\n   - Mac(X86)\n   - Mac(ARM)\n2. 下载文档：[https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/software_install-0000001053582415-V3](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/software_install-0000001053582415-V3)\n3. 下载视频教程：[https://www.bilibili.com/video/BV1Sa4y1Z7B1?p=2](https://www.bilibili.com/video/BV1Sa4y1Z7B1?p=2)\n4. 安装过程：DevEco Studio → 一路 Next即可\n5. 运行： \n\n- 基础安装：Node.js >= 16.9.1 + Install ohpm 鸿蒙包管理器\n- 注意：这里需要注意一个点，DevEco Studio 需要安装 Node 环境，这里可以去 Node 官网下载，也可以直接下载，下载版本最好和默认版本保持一致\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704911520872-68396da0-fef8-4a5f-a68e-71c85f707153.png#averageHue=%233e4145&clientId=u8b8b4713-e5d1-4&from=paste&height=718&id=uc74d66ed&originHeight=898&originWidth=1418&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=102632&status=done&style=none&taskId=ubd77cbd9-7142-4bfd-be90-94aa8ef3cc3&title=&width=1134.4)\n\n- 然后下面的 Install 表示下载的是鸿蒙的包管理系统，如果之前没有干过鸿蒙的话，这个是必选的，直接打钩就可以了\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704911657397-c47d66ec-d36f-494a-a09d-8fd982599b72.png#averageHue=%233e4145&clientId=u8b8b4713-e5d1-4&from=paste&height=661&id=u43dad5c5&originHeight=826&originWidth=1405&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=138355&status=done&style=none&taskId=u2bb7b3ac-2f82-49c2-a50f-2bea04ff0f4&title=&width=1124)\n\n- 上面过程完成之后，就是鸿蒙工具包的安装了，这些是鸿蒙开发必备的，直接 next 就可以了\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704911789310-64b85301-5d42-4dec-909e-04c7ea3d13f6.png#averageHue=%23404348&clientId=u8b8b4713-e5d1-4&from=paste&height=722&id=ub6d17659&originHeight=903&originWidth=1407&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=322476&status=done&style=none&taskId=ud95c9c40-d082-4efd-b097-a69cdb318de&title=&width=1125.6)\n\n- 接着这部分是关于鸿蒙 SDK 协议的选择，直接 Accept 即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704911859435-df2fe1e0-1cb2-4a31-adfc-644c3c7f942e.png#averageHue=%233f4246&clientId=u8b8b4713-e5d1-4&from=paste&height=934&id=ucd7dc98f&originHeight=1167&originWidth=1802&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=266692&status=done&style=none&taskId=ubd1fe695-733b-4330-a478-130dc22f43e&title=&width=1441.6)\n\n- 然后最后是确认页面了，确认以上东西之后，直接 Next 然后等待安装即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704911931015-53edab21-3f2c-461b-bd78-c417dd179225.png#averageHue=%233f4143&clientId=u8b8b4713-e5d1-4&from=paste&height=674&id=u5a506e11&originHeight=842&originWidth=1317&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=287334&status=done&style=none&taskId=u0c42d433-908a-4584-96e3-f2d75d528f9&title=&width=1053.6)\n\n- 然后以上就是 SDK 成功安装的界面了\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704911998312-34615e95-ab20-4a32-8ef1-7fe428e61964.png#averageHue=%23323642&clientId=u8b8b4713-e5d1-4&from=paste&height=757&id=u32cd10a7&originHeight=946&originWidth=1562&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=76439&status=done&style=none&taskId=uef67d270-7c17-45da-979f-939a0593ff0&title=&width=1249.6)\n\n- 然后到此就大功告成了，我们的 DevEco Studio 就安装成功了\n- 这里的话最好点击一下右下角的检查，查看自己的 SDK 是否安装成功，安装失败也不要紧，直接 install 一下就OK了\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704912123015-91a4e684-819c-431a-8e92-cab96f8bcc1c.png#averageHue=%23404244&clientId=u8b8b4713-e5d1-4&from=paste&height=744&id=ufda1c938&originHeight=930&originWidth=1423&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=230781&status=done&style=none&taskId=u5d4e6802-a847-4f55-ab89-cfae96f5c5d&title=&width=1138.4)<br />到这里就算大功告成了，然后就可以开始我们的鸿蒙开发之旅游了。\n<a name=\"CNIOl\"></a>\n\n## DevEco Studio 开发快捷键\n\n鸿蒙开发工具 DevEco Studio 的快捷键其实和 IDEA 是差不了多少的，这里我就总结了一下，感兴趣的同学可以看看：<br />这里为了方便大家进行查找，我准备了几个版本，供大家查找\n\n- PDF 版本：\n\n[0.鸿蒙 HarmonyOS DevEco Studio 常用快捷键 快捷键.pdf](https://www.yuque.com/attachments/yuque/0/2024/pdf/26315150/1704912788652-6bb58e81-6758-4f71-b6d0-885fe521bfd6.pdf)\n\n- 网站浏览版：\n\nGithub ：[https://github.com/DIDA-lJ/HarmonyOS-Learning/blob/main/DevEco%20Studio-Keymap.md](https://github.com/DIDA-lJ/HarmonyOS-Learning/blob/main/DevEco%20Studio-Keymap.md)<br />Gitee：[https://gitee.com/wkw-wzs/hongmeng-learning/blob/master/DevEco%20Studio-Keymap.md](https://gitee.com/wkw-wzs/hongmeng-learning/blob/master/DevEco%20Studio-Keymap.md)<br />这里放了 Github 和 Gitee 两个仓库的链接，不想下载的同学直接网页查看就可以了，这样就方便很多了，然后感兴趣的同学直接给项目点个 star 就行。\n<a name=\"UvsoY\"></a>\n\n# 从零到一手写 Hello World\n\n<a name=\"UEeZK\"></a>\n\n## 创建项目\n\n点击这里的 Create Project 即可开始创建我们的项目了<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704912409875-1d0b5e88-ccfd-41c1-96e3-e77b5c283e32.png#averageHue=%2331373e&clientId=u8b8b4713-e5d1-4&from=paste&height=688&id=uda79ced6&originHeight=860&originWidth=1364&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32120&status=done&style=none&taskId=u62db504d-9e26-48b4-a9d6-2b6324dc85f&title=&width=1091.2)\n<a name=\"JpW0z\"></a>\n\n## 选择项目模板\n\n这里我们选择项目模板然后进行创建，这里我们就直接选择空模板进行创建就可以了<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704912486893-a4931f9a-5784-41d0-abc1-377a1abb5e62.png#averageHue=%233d4042&clientId=u8b8b4713-e5d1-4&from=paste&height=658&id=u30bb0024&originHeight=822&originWidth=1227&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=44995&status=done&style=none&taskId=ua706c565-911c-47a3-8f90-7a7bb869c1c&title=&width=981.6)\n<a name=\"byV0t\"></a>\n\n## 填写项目信息\n\n这里就和我们正常创建项目一样，填写项目信息就可以了，不过有一个注意点，就是项目的目录不能中文名，这个切记\n\n- Project name：项目名称\n- Bundle name：这个和我们 Java 的包名称，类似根路径下的包名\n- Save location：就是本地存放路径，这里很简单，就是项目存放路径，不过注意一个点，一定要是英文目录，不能有中文名，不然可能会有莫名其妙的报错\n- SDK 版本：这里默认即可\n- Model：我们这里选择 Stage，因为华为官方说了，以后不再更新 FA 模式，这里直接选择官方推荐的 Satge 模式即可\n- Enable Super Visual：这里表示低代码模式，如果学习阶段的话可以关闭，开发的时候可以开启\n- 编译 SDK： 和上面一样即可\n- 设备类型：这里全选即可，表示手机和平板\n\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704913436370-5754f192-f09e-47e9-b8ce-4c107e65d315.png#averageHue=%233e4042&clientId=u9a1826ca-7c64-4&from=paste&height=657&id=eTYtQ&originHeight=821&originWidth=1228&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=39431&status=done&style=none&taskId=ue0a1fcf6-cfda-49fc-aafd-435ce8a7f90&title=&width=982.4)<br />完成之后点击 Finish 即可，然后其就会开始下载依赖了，这个部分和前端一样\n<a name=\"K8HME\"></a>\n\n## 项目创建成功运行画面\n\n然后下载成功之后，其下面一片绿色，则表示依赖下载完毕<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704910601912-d673ee8c-369f-4bfb-a880-c14a6bf5edaa.png#averageHue=%237c7754&clientId=u8b8b4713-e5d1-4&from=paste&height=990&id=ube0c46f4&originHeight=1237&originWidth=1722&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=203080&status=done&style=none&taskId=ue59f8e19-ccd5-4597-847a-5a65ca01a02&title=&width=1377.6)\n<a name=\"rBwlL\"></a>\n\n## 运行 Hello World \n\n依赖下载完成之后，点击右侧工具栏的 Previewer 即可，第一次编译的时间可能比较久，请稍作等待，过一会，一段 Hello World 成功显示，则表示我们大功告成了<br />![image.png](https://cdn.nlark.com/yuque/0/2024/png/26315150/1704914052524-f848226a-9b5e-43a1-9ea8-9661bfa37cc8.png#averageHue=%2353715a&clientId=u9a1826ca-7c64-4&from=paste&height=1074&id=ucc88c5f6&originHeight=1342&originWidth=2239&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=173250&status=done&style=none&taskId=u931f634f-eae9-4f46-b1b2-1d6ba45b7a4&title=&width=1791.2)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1627889630378479618/SnXidToM-3.png",
        "language": null,
        "viewNum": 11,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1627889630378479618",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-14T07:42:06.000+00:00",
        "updateTime": "2024-01-15T05:47:21.000+00:00",
        "user": {
          "id": "1627889630378479618",
          "planetCode": "2784",
          "userName": "答案说明所有",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1627889630378479618/FYBQxM7a-Screenshot_20230717_113840.jpg",
          "gender": 1,
          "userProfile": "目标大厂，冲冲冲！",
          "userRole": "vip",
          "interests": [],
          "place": "广东",
          "birthday": "2023-05-12",
          "school": "广东石油化工学院",
          "major": "数据科学与大数据技术",
          "education": null,
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "大数据",
          "goal": "实习",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-02-27T11:51:43.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-21T04:35:07.000+00:00",
          "updateTime": "2024-01-04T07:44:31.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1746398732812820481",
        "title": "OJ竞赛排行榜统计逻辑设计与代码实现",
        "description": "介绍实现竞赛排行榜功能的设计思路和代码实现，包括数据库表设计和代码逻辑设计（Java）",
        "content": "## 引言\n\n排行榜功能在各类竞赛中都扮演着至关重要的角色，特别是在在线评测（OJ）竞赛中，其不可或缺的存在使得竞赛更具有活力和竞争性。排行榜以直观的方式呈现了参赛者的表现，为竞赛举办方提供了全面而清晰的数据，有助于深入了解参与者的水平、策略和表现。\n通过排行榜功能，竞赛主办方能够迅速准确地了解每位参赛选手的最优答题情况。这不仅有助于评估个体的实力和技能水平，还为组织者提供了一个全景视图，使其能够比较各参赛者之间的相对表现。这样的比较不仅有助于确认竞赛结果，还能为颁奖和奖励制度的制定提供有力的参考依据。\n排行榜功能的扩展进一步增强了竞赛的可视化和分析性质。通过引入更多的数据维度，如解答速度、正确率、题目难度等，排行榜不仅呈现了参赛者的总体排名，还提供了更为详细和深入的分析。这样的深度分析有助于识别优秀选手在特定方面的优势，为奖励制度的个性化设计提供了基础。\n此外，排行榜功能也为参赛者提供了实时的竞技体验。他们可以随时了解自己在比赛中的排名，并与其他选手进行比较。这种实时性的反馈不仅能够激发竞争激情，还有助于参赛者更好地调整策略，迅速适应竞技环境，提高个人表现。\n总体而言，排行榜功能的扩展不仅为竞赛主办方提供了更全面的参赛者数据，也为参赛者带来了更加激烈和有趣的竞技体验。这种功能的不断升级和优化将进一步推动竞赛的发展，为广大参与者和组织者带来更为丰富和满足的竞技体验。\n\n## 分析\n\n根据引言部分，我们可以分析出排行榜功能设计时要注意的关键点：\n\n1. **尽可能实时**：**尽可能**实时而不是说**完全**实时，是因为用户答题数据的提交、更新统计不是实时的（答题者很多，我们要对提交的答案做异步处理，以提升用户体验，而异步就意味着不一定实时）\n2. 展示参赛者**最优**答题情况：要维护竞赛下各用户每个题目的**最优答题情况**，作为题目的最好成绩\n3. 排行榜排名标准一般是：总分->总耗时->总耗用空间：这个顺序并不绝对，但要固定\n4. 排行榜数据仅在竞赛开始后可见：即竞赛前：不可见；竞赛中：动态变化；竞赛后：可见但不变（可由不能提交题目控制）\n\n## 设计思路\n\n影响排行榜数据的主要包含：答题模块和统计模块，答题模块重在更新，统计模块重在统计和返回形式的转换。\n![h2Q7j.png](https://i0.imgs.ovh/2024/01/14/h2Q7j.png)\n\n## 数据库设计\n\n### 概览\n\n竞赛模块，一共可设计三张表：\n\n1. game：竞赛表，包含竞赛的基本信息\n2. user_game：用户-竞赛关联表，绑定每个竞赛下的用户\n3. game_question：竞赛-题目关联表，维护每个竞赛下的题目\n4. game_rank：竞赛-排名表，记录每个竞赛中每个用户的总分、总耗时、总空间和各题目的最优答题情况集合（json字符串存储）\n\n### game_rank\n\n#### 结构：\n\n![h2RDI.png](https://i0.imgs.ovh/2024/01/14/h2RDI.png)\n虽然总分、总耗时和总耗用空间可以根据最优答题情况（gameDetail）动态生成，但每次都要变动，尤其竟赛结束后还要动态计算时间是有点浪费了点，于是用一点空间换时间，况且，维护也不麻烦。\n另外，竞赛详情（gameDetail）的对象结构如下：\n![h2eZV.png](https://i0.imgs.ovh/2024/01/14/h2eZV.png)\n\n1. gameId和userId作为竞赛和排行模块重要的参数，记录一下有利于后续的排行榜数据统计和未来可能的功能拓展。\n2. submitDetail用map方式存储，再合适不过\n\n#### sql代码：\n\n```sql\n-- ----------------------------\n-- Table structure for game_rank\n-- ----------------------------\nDROP TABLE IF EXISTS `game_rank`;\nCREATE TABLE `game_rank`  (\n  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',\n  `gameId` bigint NULL DEFAULT NULL COMMENT '竞赛id',\n  `userId` bigint NULL DEFAULT NULL COMMENT '用户id',\n  `userName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户昵称',\n  `totalMemory` int NULL DEFAULT NULL COMMENT '总空间（kb）',\n  `totalTime` int NULL DEFAULT NULL COMMENT '总用时（ms）',\n  `totalScore` int NULL DEFAULT NULL COMMENT '总得分',\n  `gameDetail` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '竞赛详情',\n  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n  `isDelete` tinyint NOT NULL DEFAULT 0 COMMENT '是否删除',\n  PRIMARY KEY (`id`) USING BTREE,\n  INDEX `idx_gameId`(`gameId` ASC) USING BTREE,\n  INDEX `idx_userId`(`userId` ASC) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;\n```\n\n## 代码设计与实现\n\n### 实体类设计\n\n在排行榜模块中，涉及的实体类及其关系图如下：\n\n1. GameRank\n2. GameDetail\n3. GameDetailUnit\n4. GameRankDetail\n\n![h2gxJ.png](https://i0.imgs.ovh/2024/01/14/h2gxJ.png)\n\n实体代码如下：\n\n1. **GameRank**\n\n```java\npackage sspu.zzx.sspuoj.model.entity;\n\nimport com.baomidou.mybatisplus.annotation.*;\nimport lombok.Data;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * @author ZZX\n * @TableName game_rank\n */\n@TableName(value = \"game_rank\")\n@Data\npublic class GameRank implements Serializable\n{\n    /**\n     * id\n     */\n    @TableId(type = IdType.AUTO)\n    private Long id;\n\n    /**\n     * 竞赛id\n     */\n    private Long gameId;\n\n    /**\n     * 用户id\n     */\n    private Long userId;\n\n    /**\n     * 用户昵称\n     */\n    private String userName;\n\n    /**\n     * 提交总空间消耗\n     */\n    private Integer totalMemory;\n\n    /**\n     * 提交总耗时\n     */\n    private Integer totalTime;\n\n    /**\n     * 竞赛总得分\n     */\n    private Integer totalScore;\n\n    /**\n     * 竞赛详情\n     */\n    private String gameDetail;\n\n    /**\n     * 创建时间\n     */\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n\n    /**\n     * 更新时间\n     */\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n\n    /**\n     * 是否删除\n     */\n    private Integer isDelete;\n\n    @TableField(exist = false)\n    private static final long serialVersionUID = 1L;\n}\n```\n\n2. **GameDetail**\n\n```java\npackage sspu.zzx.sspuoj.model.dto.game;\n\nimport lombok.Data;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\n/**\n * @version 1.0\n * @Author ZZX\n * @Date 2024/1/10 16:01\n */\n@Data\npublic class GameDetail implements Serializable\n{\n    /**\n     * 竞赛id\n     */\n    private Long gameId;\n\n    /**\n     * 用户id\n     */\n    private Long userId;\n\n    /**\n     * 题目提交详情\n     * key：题目id\n     * val：最优答题情况\n     */\n    private Map<Long, GameDetailUnit> submitDetail;\n\n    private static final long serialVersionUID = 1L;\n}\n\n```\n\n3. **GameDetailUnit**\n\n```java\npackage sspu.zzx.sspuoj.model.dto.game;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\n\n/**\n * @version 1.0\n * @Author ZZX\n * @Date 2024/1/10 10:47\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class GameDetailUnit implements Serializable\n{\n    /**\n     * 单题id\n     */\n    private Long id;\n\n    /**\n     * 单题名称\n     */\n    private String name;\n\n    /**\n     * 单题得分\n     */\n    private Integer score;\n\n    /**\n     * 单题耗时\n     */\n    private Integer timeCost;\n\n    /**\n     * 单题耗内存\n     */\n    private Integer memoryCost;\n\n    /**\n     * 比较是否比另一个好\n     *\n     * @param other\n     * @return\n     */\n    public boolean isBetter(GameDetailUnit other)\n    {\n        // 首先比较分数是否更大\n        if (this.score > other.getScore())\n        {\n            return true;\n        }\n        if (this.score < other.getScore())\n        {\n            return false;\n        }\n        // 其次比较耗时是否更少\n        if (this.timeCost < other.getTimeCost())\n        {\n            return true;\n        }\n        if (this.timeCost > other.getTimeCost())\n        {\n            return false;\n        }\n        // 最后比较耗费空间是否更少\n        if (this.memoryCost < other.getMemoryCost())\n        {\n            return true;\n        }\n        return false;\n    }\n\n    private static final long serialVersionUID = 1L;\n}\n\n```\n\n4. **GameRankDetail**\n\n```java\npackage sspu.zzx.sspuoj.model.vo.game;\n\nimport lombok.Data;\nimport sspu.zzx.sspuoj.model.dto.game.GameDetailUnit;\n\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n * @version 1.0\n * @Author ZZX\n * @Date 2024/1/10 16:06\n */\n@Data\npublic class GameRankDetail implements Serializable\n{\n    /**\n     * 名次\n     */\n    private Integer rankOrder;\n\n    /**\n     * 答题者id\n     */\n    private Long userId;\n\n    /**\n     * 答题者昵称\n     */\n    private String userName;\n\n    /**\n     * 总分\n     */\n    private Integer totalScore;\n\n    /**\n     * 总耗时\n     */\n    private Integer totalTime;\n\n    /**\n     * 总耗用内存\n     */\n    private Integer totalMemory;\n\n    /**\n     * 最优答题情况集合\n     */\n    private List<GameDetailUnit> questionDetails;\n\n    private static final long serialVersionUID = 1L;\n}\n```\n\n### 判题模块\n\n这块在答题模块有用到，因为要等待异步的判题结果：\n\n```java\n    /**\n     * 提交题目\n     *\n     * @param questionSubmitAddRequest\n     * @param loginUser\n     * @return\n     */\n    @Override\n    public long doQuestionSubmit(QuestionSubmitAddRequest questionSubmitAddRequest, User loginUser)\n    {\n        // 校验编程语言是否合法\n        String language = questionSubmitAddRequest.getLanguage();\n        QuestionSubmitLanguageEnum languageEnum = QuestionSubmitLanguageEnum.getEnumByValue(language);\n        if (languageEnum == null)\n        {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR, \"编程语言错误\");\n        }\n        long questionId = questionSubmitAddRequest.getQuestionId();\n        // 判断实体是否存在，根据类别获取实体\n        Question question = questionService.getById(questionId);\n        if (question == null)\n        {\n            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);\n        }\n        // 是否已提交题目\n        long userId = loginUser.getId();\n        // 检查是否存在该用户提交该题目但正在判题的记录\n        QueryWrapper<QuestionSubmit> wrapper = new QueryWrapper<>();\n        wrapper.eq(\"userId\", userId);\n        wrapper.eq(\"questionId\", questionId);\n        wrapper.eq(\"status\", QuestionSubmitStatusEnum.WAITING.getValue());\n        QuestionSubmit waitingQuestionSubmit = this.getOne(wrapper);\n        if (waitingQuestionSubmit != null)\n        {\n            throw new BusinessException(ErrorCode.API_REQUEST_ERROR, \"题目正在判题中，请勿重复提交！\");\n        }\n        // 每个用户串行提交题目\n        QuestionSubmit questionSubmit = new QuestionSubmit();\n        questionSubmit.setUserId(userId);\n        questionSubmit.setQuestionId(questionId);\n        questionSubmit.setCode(questionSubmitAddRequest.getCode());\n        questionSubmit.setLanguage(language);\n        // 设置初始状态\n        questionSubmit.setStatus(QuestionSubmitStatusEnum.WAITING.getValue());\n        questionSubmit.setJudgeInfo(\"{}\");\n        boolean save = this.save(questionSubmit);\n        if (!save)\n        {\n            throw new BusinessException(ErrorCode.SYSTEM_ERROR, \"数据插入失败\");\n        }\n        Long questionSubmitId = questionSubmit.getId();\n        // 异步执行判题服务\n        CompletableFuture.runAsync(() ->\n        {\n            judgeService.doJudge(questionSubmitId);\n            // 同时更新题目的通过数和通过总数\n            question.setSubmitNum(question.getSubmitNum() + 1);\n            QuestionSubmit resQuestionSubmit = this.getById(questionSubmitId);\n            String judgeInfo = resQuestionSubmit.getJudgeInfo();\n            JSONObject jsonObject = JSON.parseObject(judgeInfo);\n            if (JudgeInfoMessageEnum.ACCEPTED.getValue().equals(jsonObject.getString(\"message\")))\n            {\n                question.setAcceptedNum(question.getAcceptedNum() + 1);\n            }\n            this.questionService.updateById(question);\n        });\n        return questionSubmitId;\n    }\n```\n\n```java\npackage sspu.zzx.sspuoj.model.judge.model;\n\nimport lombok.Data;\n\n/**\n * 判题信息\n */\n@Data\npublic class JudgeInfo {\n\n    /**\n     * 程序执行信息\n     */\n    private String message;\n\n    /**\n     * 消耗内存\n     */\n    private Long memory;\n\n    /**\n     * 消耗时间（KB）\n     */\n    private Long time;\n}\n\n```\n\n### 答题模块\n\n![h2tjW.png](https://i0.imgs.ovh/2024/01/14/h2tjW.png)\n处理提交题目的代码如下（逻辑看注释)\n\n```java\n @Override\n    public Long questionSubmit(GameQuestionSubmitRequest gameQuestionSubmitRequest)\n    {\n        QuestionSubmitAddRequest questionSubmitAddRequest = gameQuestionSubmitRequest.getQuestionSubmitAddRequest();\n        Long gameId = gameQuestionSubmitRequest.getGameId();\n        if (questionSubmitAddRequest == null || gameId == null)\n        {\n            throw new BusinessException(ErrorCode.PARAMS_ERROR);\n        }\n        Game game = gameMapper.selectById(gameId);\n        if (game == null)\n        {\n            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR, \"竞赛不存在\");\n        }\n        Date startTime = game.getStartTime();\n        Date endTime = game.getEndTime();\n        // 判断竞赛是否已经开始\n        Date currentDate = new Date();\n        if (startTime.after(currentDate))\n        {\n            throw new BusinessException(ErrorCode.OPERATION_ERROR, \"竞赛未开始\");\n        }\n        // 判断竞赛是否已经结束\n        if (endTime.before(currentDate))\n        {\n            throw new BusinessException(ErrorCode.OPERATION_ERROR, \"竞赛已结束\");\n        }\n        final User loginUser = userService.getLoginUser(null);\n        long submitId = questionSubmitService.doQuestionSubmit(questionSubmitAddRequest, loginUser);\n        // 同时异步更新排行榜信息\n        CompletableFuture.runAsync(() ->\n        {\n            // 更新用户提交成绩信息\n            QuestionSubmit nowSubmit = questionSubmitService.getById(submitId);\n            // 获得该竞赛各题目的满分\n            QueryWrapper<GameQuestion> gameQuestionQueryWrapper = new QueryWrapper<>();\n            gameQuestionQueryWrapper.eq(\"gameId\", gameId);\n            List<GameQuestion> gameQuestionList = gameQuestionMapper.selectList(gameQuestionQueryWrapper);\n            Map<Long, Integer> questionIdToFullScore = gameQuestionList.stream().collect(Collectors.toMap(GameQuestion::getQuestionId, GameQuestion::getFullScore));\n            // 获得当前用户在当前竞赛中的提交信息\n            QueryWrapper<GameRank> gameRankQueryWrapper = new QueryWrapper<>();\n            gameRankQueryWrapper.eq(\"userId\", loginUser.getId()).eq(\"gameId\", gameId);\n            GameRank gameRank = gameRankMapper.selectOne(gameRankQueryWrapper);\n            // 为空新建一个gameRank记录并将当前答题情况插入更新（因为第一次统计时，还没新建这个记录）\n            if (gameRank == null)\n            {\n                gameRank = new GameRank();\n                gameRank.setUserId(loginUser.getId());\n                gameRank.setUserName(loginUser.getUserName());\n                gameRank.setGameId(gameId);\n                GameDetail gameDetail = new GameDetail();\n                gameDetail.setGameId(gameId);\n                gameDetail.setUserId(loginUser.getId());\n                Map<Long, GameDetailUnit> gameDetailUnitMap = new HashMap<>();\n                GameDetailUnit gameDetailUnit = getGameDetailUnit(nowSubmit, questionIdToFullScore);\n                gameDetailUnitMap.put(nowSubmit.getQuestionId(), gameDetailUnit);\n                gameDetail.setSubmitDetail(gameDetailUnitMap);\n                gameRank.setGameDetail(JSONUtil.toJsonStr(gameDetail));\n                gameRank.setTotalScore(gameDetailUnit.getScore());\n                gameRank.setTotalMemory(gameDetailUnit.getMemoryCost());\n                gameRank.setTotalTime(gameDetailUnit.getTimeCost());\n                gameRankMapper.insert(gameRank);\n            }\n            // gameDetail()为空时，则将当前答题情况插入更新\n            else if (StringUtils.isBlank(gameRank.getGameDetail()))\n            {\n                GameDetail gameDetail = new GameDetail();\n                gameDetail.setGameId(gameId);\n                gameDetail.setUserId(loginUser.getId());\n                Map<Long, GameDetailUnit> gameDetailUnitMap = new HashMap<>();\n                GameDetailUnit gameDetailUnit = getGameDetailUnit(nowSubmit, questionIdToFullScore);\n                gameDetailUnitMap.put(nowSubmit.getQuestionId(), gameDetailUnit);\n                gameDetail.setSubmitDetail(gameDetailUnitMap);\n                gameRank.setGameDetail(JSONUtil.toJsonStr(gameDetail));\n                gameRank.setTotalScore(gameDetailUnit.getScore());\n                gameRank.setTotalMemory(gameDetailUnit.getMemoryCost());\n                gameRank.setTotalTime(gameDetailUnit.getTimeCost());\n                gameRankMapper.updateById(gameRank);\n            } else\n            {\n                // 对比两个版本的当前题目提交信息，保留最优的\n                GameDetail dbGameDetail = JSONUtil.toBean(gameRank.getGameDetail(), GameDetail.class);\n                Map<Long, GameDetailUnit> dbSubmitDetail = dbGameDetail.getSubmitDetail();\n                // 获得数据库已有的该题目提交信息\n                GameDetailUnit dbGameDetailUnit = dbSubmitDetail.get(nowSubmit.getQuestionId());\n                // 组装当前的该题目提交信息\n                GameDetailUnit gameDetailUnit = getGameDetailUnit(nowSubmit, questionIdToFullScore);\n                if (dbGameDetailUnit == null)\n                {\n                    dbSubmitDetail.put(nowSubmit.getQuestionId(), gameDetailUnit);\n                    dbGameDetail.setSubmitDetail(dbSubmitDetail);\n                    gameRank.setGameDetail(JSONUtil.toJsonStr(dbGameDetail));\n                    gameRank.setTotalScore(gameRank.getTotalScore() + gameDetailUnit.getScore());\n                    gameRank.setTotalMemory(gameRank.getTotalMemory() + gameDetailUnit.getMemoryCost());\n                    gameRank.setTotalTime(gameRank.getTotalTime() + gameDetailUnit.getTimeCost());\n                    gameRankMapper.updateById(gameRank);\n                } else\n                {\n                    // 如果新的优于目前的\n                    if (gameDetailUnit.isBetter(dbGameDetailUnit))\n                    {\n                        dbSubmitDetail.put(nowSubmit.getQuestionId(), gameDetailUnit);\n                        dbGameDetail.setSubmitDetail(dbSubmitDetail);\n                        gameRank.setGameDetail(JSONUtil.toJsonStr(dbGameDetail));\n                        gameRank.setTotalScore(gameRank.getTotalScore() - dbGameDetailUnit.getScore() + gameDetailUnit.getScore());\n                        gameRank.setTotalMemory(gameRank.getTotalMemory() - dbGameDetailUnit.getMemoryCost() + gameDetailUnit.getMemoryCost());\n                        gameRank.setTotalTime(gameRank.getTotalTime() - dbGameDetailUnit.getTimeCost() + gameDetailUnit.getTimeCost());\n                        gameRankMapper.updateById(gameRank);\n                    }\n                }\n            }\n        });\n        return submitId;\n    }\n```\n\n```java\n    public GameDetailUnit getGameDetailUnit(QuestionSubmit nowSubmit, Map<Long, Integer> questionIdToFullScore)\n    {\n        GameDetailUnit gameDetailUnit = new GameDetailUnit();\n        gameDetailUnit.setId(nowSubmit.getQuestionId());\n        Question question = questionService.getById(nowSubmit.getQuestionId());\n        gameDetailUnit.setName(question.getTitle());\n        if (StringUtils.isBlank(nowSubmit.getJudgeInfo()) || \"{}\".equals(nowSubmit.getJudgeInfo()))\n        {\n            try\n            {\n                // todo 有死循环隐患，因为可能这块依赖于答题结果是否在异步处理后获得答题情况值，后续再优化\n                while (StringUtils.isBlank(nowSubmit.getJudgeInfo()) || \"{}\".equals(nowSubmit.getJudgeInfo()))\n                {\n                    TimeUnit.SECONDS.sleep(5);\n                    nowSubmit = questionSubmitService.getById(nowSubmit.getId());\n                }\n            } catch (InterruptedException e)\n            {\n                e.printStackTrace();\n            }\n        }\n        JudgeInfo judgeInfo = JSONUtil.toBean(nowSubmit.getJudgeInfo(), JudgeInfo.class);\n        gameDetailUnit.setTimeCost(Math.toIntExact(judgeInfo.getTime()));\n        gameDetailUnit.setMemoryCost(Math.toIntExact(judgeInfo.getMemory()));\n        String judgeInfoMessage = judgeInfo.getMessage();\n        // todo 打分逻辑后续可以再完善，等判题机写完后\n        if (JudgeInfoMessageEnum.ACCEPTED.getValue().equals(judgeInfoMessage))\n        {\n            // 如果ACCEPTED则打满分\n            gameDetailUnit.setScore(questionIdToFullScore.get(nowSubmit.getQuestionId()));\n        } else\n        {\n            gameDetailUnit.setScore(0);\n        }\n        return gameDetailUnit;\n    }\n```\n\n### 统计模块\n\n![h2JVv.png](https://i0.imgs.ovh/2024/01/14/h2JVv.png)\n处理排行榜数据和排序的代码如下（逻辑看注释)\n\n```java\n    @Override\n    public List<GameRankDetail> getRankByGameId(long gameId)\n    {\n        // 获得竞赛的题目id\n        QueryWrapper<GameQuestion> gameQuestionQueryWrapper = new QueryWrapper<>();\n        gameQuestionQueryWrapper.eq(\"gameId\", gameId);\n        List<GameQuestion> gameQuestions = gameQuestionMapper.selectList(gameQuestionQueryWrapper);\n        List<Long> gameQuestionIds = gameQuestions.stream().map(GameQuestion::getQuestionId).collect(Collectors.toList());\n        // 获得参加竞赛的所有用户\n        QueryWrapper<UserGame> userGameQueryWrapper = new QueryWrapper<>();\n        userGameQueryWrapper.eq(\"gameId\", gameId);\n        List<UserGame> userGames = userGameMapper.selectList(userGameQueryWrapper);\n        List<Long> userIds = userGames.stream().map(UserGame::getUserId).collect(Collectors.toList());\n        // 计算用户最优答题集合\n        List<GameRankDetail> gameRankDetails = new ArrayList<>(userGames.size());\n        for (Long userId : userIds)\n        {\n            // 获得排名记录\n            QueryWrapper<GameRank> gameRankQueryWrapper = new QueryWrapper<>();\n            gameRankQueryWrapper.eq(\"userId\", userId).eq(\"gameId\", gameId);\n            GameRank gameRank = gameRankMapper.selectOne(gameRankQueryWrapper);\n            // 无排名记录则新建\n            User user = userService.getById(userId);\n            GameRankDetail gameRankDetail = new GameRankDetail();\n            gameRankDetail.setUserId(userId);\n            gameRankDetail.setUserName(user.getUserName());\n            gameRankDetail.setTotalScore(0);\n            gameRankDetail.setTotalMemory(0);\n            gameRankDetail.setTotalTime(0);\n            // 无排名记录则新建\n            if (gameRank == null)\n            {\n                gameRank = new GameRank();\n                gameRank.setGameId(gameId);\n                gameRank.setUserId(userId);\n                gameRank.setUserName(user.getUserName());\n                gameRank.setTotalScore(0);\n                gameRank.setTotalMemory(0);\n                gameRank.setTotalTime(0);\n                gameRankMapper.insert(gameRank);\n                gameRankDetail.setQuestionDetails(getQuestionDetails(gameQuestionIds, null));\n            } else\n            {\n                // 有排名记录但无这道题则新建\n                if (StringUtils.isBlank(gameRank.getGameDetail()))\n                {\n                    gameRankDetail.setQuestionDetails(getQuestionDetails(gameQuestionIds, null));\n                } else\n                {\n                    GameDetail gameDetail = JSONUtil.toBean(gameRank.getGameDetail(), GameDetail.class);\n                    // 统计总分、总耗时和总好空间\n                    calcGameDetailConfig(gameDetail, gameRankDetail);\n                    // 更新题目详情\n                    gameRankDetail.setQuestionDetails(getQuestionDetails(gameQuestionIds, gameDetail));\n                }\n            }\n            gameRankDetails.add(gameRankDetail);\n        }\n        // 排序\n        List<GameRankDetail> orderGameRankDetails = gameRankDetails.stream().sorted(Comparator.comparing(GameRankDetail::getTotalScore).reversed().thenComparing(GameRankDetail::getTotalTime).thenComparing(GameRankDetail::getTotalMemory)).collect(Collectors.toList());\n        // 安排名次\n        for (int i = 0; i < orderGameRankDetails.size(); i++)\n        {\n            orderGameRankDetails.get(i).setRankOrder(i + 1);\n        }\n        // 返回\n        return orderGameRankDetails;\n    }\n```\n\n## 效果展示\n\n最终展示效果如下，可以达到尽可能显示的效果：\n竞赛开始后，未答题前获取排行榜数据会设置初始值，类似下图：\n![h2zke.png](https://i0.imgs.ovh/2024/01/14/h2zke.png)\n有用户答题后会更新排行榜数据，类似下图：\n![h2Ut3.png](https://i0.imgs.ovh/2024/01/14/h2Ut3.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 9,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1721896042632441858",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-14T05:07:59.000+00:00",
        "updateTime": "2024-01-15T05:41:38.000+00:00",
        "user": {
          "id": "1721896042632441858",
          "planetCode": "29240",
          "userName": "南侠（准）",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELkfM4IsxxWrB70flGuaDcq55mDxh8r4DuwOJLuluSmRCH9Pk1MFibry5icVgHtfwMmnYGqT49svVKV3X1wMer2OCC3ob5leZX5lF8HMbPo1Qww/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-11-05T14:14:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-11-07T14:23:02.000+00:00",
          "updateTime": "2023-11-09T14:34:06.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "后端",
          "项目",
          "笔记"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1746066250653507586",
        "title": "不良网站",
        "description": "只传播不良内容的网站（bushi）",
        "content": "言归正传，第一次交作业，改编自伙伴匹配系统，由根据标签匹配用户改编为根据标签匹配角色。作为不良人老粉，当第一次看到伙伴匹配系统时，就想着做一个不良人角色相关的网站，看过不良人的都知道，不良人或许真的可以称得上是国漫巅峰（不喜勿喷），里面的角色也是各具特色，别有一番风味。那么，不良网站主要就是提供了一个平台，用户可以创建自己喜欢的角色，公开显示到网站，所有人都可以看到网站上的所有角色。另外，如果你对不良人中的某一个组织或者地域或者人物关系感兴趣，你可以创建一个队伍，与你兴趣相投的用户可以加入到队伍，你们可以在队伍中展开讨论（目前聊天功能尚未开放，处于开发阶段）。\n好了，以上差不多就是网站的简单介绍了，欢迎感兴趣的朋友访问哦。\n\n网站链接：https://badboy-frontend-88532-7-1323701492.sh.run.tcloudbase.com\n\n当然，在开发网站过程中，也学到了很多东西。每当遇到一个全新的知识点时，我都会记录下来，等到空闲时间再吃透，同样做好记录，方便之后查阅。详情可参考（由于网站处于开发阶段，一些知识尚未解决，只是做了问题记录）：https://www.yuque.com/buguyiqiexiangqianchong/tw24ry/mzpbk6oasiegrp2u#DlURY\n\n附上页面预览图：\n\n![微信图片_20240113134426.png](https://pic.code-nav.cn/post_picture/1738514574744772610/c8DHGjyu-微信图片_20240113134426.png)\n\n![微信图片_20240113134458.png](https://pic.code-nav.cn/post_picture/1738514574744772610/lhPWPm44-微信图片_20240113134458.png)\n\n![微信图片_20240113134528.png](https://pic.code-nav.cn/post_picture/1738514574744772610/g5HVfaCt-微信图片_20240113134528.png)\n\n![微信图片_20240113134627.png](https://pic.code-nav.cn/post_picture/1738514574744772610/bEtGf6Sq-微信图片_20240113134627.png)\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1738514574744772610/lRwU12zi-R-C.jpg",
        "language": null,
        "viewNum": 26,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1738514574744772610",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-13T07:06:49.000+00:00",
        "updateTime": "2024-01-15T06:05:40.000+00:00",
        "user": {
          "id": "1738514574744772610",
          "planetCode": "21187",
          "userName": "badboy",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIYu0BicvLby7wQBHuQtrB7KgYGa2jxcpM0DSxxB0YNClJCsHhrlwUZD3yIm0tS4VIazZv8B0DyvKVBbQj6MNUnEHk7mopy9u093vc1vPbC7QQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-09-26T07:26:47.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-12-23T10:59:09.000+00:00",
          "updateTime": "2024-01-11T09:21:20.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "后端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1745767317930778626",
        "title": "用我这套模板，几分钟做出文档网站！",
        "description": null,
        "content": "大家好，我是保姆皮，最近我上线了自己的《编程宝典》网站，可以在线阅读我分享过的各种编程学习路线和知识干货。\n\n> 指路：https://codefather.cn/\n\n![](https://pic.yupi.icu/1/image-20231207103516335.png)\n\n不少小伙伴催我出教程，说也想做个类似的文档网站。\n\n所以我用最快的速度出了 “保姆级文档网站制作教程”，并且开源了一套网站模板。大家只需要几分钟的时间，就能快速做出同款的、精简的文档网站。\n\n推荐观看视频教程：https://www.bilibili.com/video/BV1LQ4y1V79r/\n\n以下为文字版教程：\n\n\n\n## 引言\n\n首先，很多同学肯定会觉得这个网站的风格比较眼熟。没错，这是基于 VuePress 静态网站生成器开发的。\n\n有同学问了，你咋不用 vitepress 嘞？\n\n啊，也用过，但是在生态和成熟度上不及 VuePress，折腾一番后还是选择返璞归真。\n\n别看这么一个网站非常精简，但是想做好它，这里面的门道可多着呢。你要阅读 VuePress 的官方文档，还要在琳琅满目的插件中做选择，很费时间。\n\n我出这期教程的目的，就是帮大家做做减法，不用阅读那老长的官方文档，我帮大家选好了插件。甚至，我给大家提供了一套我们自己增强的、开箱即用的文档网站模板。\n\n以后你要做自己的文档网站，直接用这个模板，不用写代码，有手就行。\n\n\n\n## VuePress 文档网站制作教程\n\n### 一、项目启动\n\n先花 30 秒的时间启动项目。\n\n首先打开我的开源项目 codefather，切换分支为 `template` 模板。\n\n> 指路：https://github.com/liyupi/codefather\n\n![](https://pic.yupi.icu/1/1701828341298-db31f118-d2c2-4bd0-ac5b-c266b59220ce.png)\n\n然后下载代码压缩包：\n\n![](https://pic.yupi.icu/1/1701828425697-03c94a85-7238-4360-b1a8-ebc5642bbbf2.png)\n\n\n\n解压后，用 WebStorm 或 VS Code 等开发工具打开项目。\n\n项目基于 VuePress 实现，需要 Node 和 Npm 环境，尽量和我的版本号保持一致防止后面出现莫名其妙的报错，没有的同学请到官网安装一下。\n\n![](https://pic.yupi.icu/1/1701828667354-1e704075-bb03-4ede-b1d5-2189bd908e54.png)\n\n\n\n首次运行前，需要运行 `npm install` 命令安装依赖：\n\n![](https://pic.yupi.icu/1/1701828742475-2114b1aa-a9df-4f75-a4bc-f8079c792bf2.png)\n\n\n\n安装依赖成功后，在 `package.json` 文件中点击 `docs:dev` 运行即可：\n\n![](https://pic.yupi.icu/1/1701828797321-bd4e0815-e9f3-4dd9-a4c7-a4de923915f3.png)\n\n\n\n运行成功，默认在本地的 8080 端口，就能访问到网站啦！\n\n![](https://pic.yupi.icu/1/1701829057165-caec05a2-684f-4b12-9375-bf0fc532d417.png)\n\n\n\n接下来，我会详细讲解这套 VuePress 模板，包括目录结构、基本配置、主题配置、插件配置等，让大家在学会 VuePress 的基础上、能灵活运用这套模板轻松定制网站。\n\n\n\n### 二、模板目录结构\n\n先来看下 VuePress 模板的目录结构，如下图：\n\n![](https://pic.yupi.icu/1/1701829618648-2f58ea87-d472-459f-9bef-889602b11483.png)\n\n\n\n所有的文档（目录）直接放到项目根目录下即可。\n\n\n\n### 三、基本配置\n\n我们打开 VuePress 的核心配置文件 `config.ts`，所有的配置基本都集中在这个文件，可以在这里全局改变网站的内容、主题样式、使用插件增强能力等。\n\n\n\n先来看一些基本配置：\n\n\n\n#### 1、网站基本信息\n\n包括网站标题、描述，还有我们自定义的作者、域名、全局标签：\n\n```javascript\nconst author = \"程序员鱼皮\";\nconst domain = \"https://codefather.cn\";\nconst tags = [\"程序员\", \"编程\", \"计算机\"];\n\nexport default defineConfig({\n  title: \"鱼皮的编程宝典\",\n  description: \"贴心的编程学习路线，全面的编程知识百科\",\n  ...\n});\n```\n\n\n\n#### 2、网站 head 标签\n\nhead 标签作为 HTML 网页文件的大脑，通常包含了网页的重要基本信息，比如上面提到的网页标题、描述等。\n\n使用 VuePress 工具，我们可以在 head 配置中添加网站 head 标签信息，比如设置站点图标、设置有利于 SEO（搜索引擎优化）的元信息、添加第三方统计分析代码等：\n\n```javascript\nhead: [\n  // 站点图标\n  [\"link\", { rel: \"icon\", href: \"/favicon.ico\" }],\n  // SEO\n  [\n    \"meta\",\n    {\n      name: \"keywords\",\n      content:\n        \"程序员鱼皮, 编程学习路线, 编程知识百科, Java, 编程导航, 前端, 开发, 编程分享, 项目, IT, 求职, 面经\",\n    },\n  ],\n  // 百度统计\n  [\n    \"script\",\n    {},\n    `\n      var _hmt = _hmt || [];\n      (function() {\n        var hm = document.createElement(\"script\");\n        hm.src = \"https://hm.baidu.com/hm.js?2675818a983a3131404cee835018f016\";\n        var s = document.getElementsByTagName(\"script\")[0]; \n        s.parentNode.insertBefore(hm, s);\n      })();\n    `,\n  ],\n],\n```\n\n\n\n#### 3、永久链接\n\n默认情况下，VuePress 是根据文档层级生成的访问链接，如下图：\n\n![](https://pic.yupi.icu/1/1701830771997-fbcea109-8c66-4286-989e-f46f6da7d82a.png)\n\n\n\n但如果文档存放的目录改变了，那么原有的链接就会失效，会影响 SEO 和用户访问。\n\n所以建议使用永久链接，只要在 `config.ts` 中加上这行配置即可：\n\n```javascript\npermalink: \"/:slug\",\n```\n\n\n\n开启永久链接后，系统自动根据文章标题生成链接地址，会更简短、精确，不会被文档目录结构影响。\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701830847837-543aed3e-1da3-4439-a269-ba4f977feb8a.png)\n\n\n\n永久链接的生成规则可以自己配置，或者给某个页面定制永久链接，详见官方文档。\n\n> 官方文档：[https://vuepress.vuejs.org/zh/guide/permalinks.html#%E8%83%8C%E6%99%AF](https://vuepress.vuejs.org/zh/guide/permalinks.html#背景)\n\n\n\n#### 4、开启文件热更新\n\nVuePress 默认提供了热更新，改动文档或配置时会自动更新网站，但是范围有限，如果是自定义的 js、ts 等前端文件，修改后不会触发热更新。\n\n可以添加 `extraWatchFiles` 配置解决，为特定范围的文件开启热更新。\n\n比如模板中所有的 ts 文件和侧边栏配置文件：\n\n```javascript\n// 监听文件变化，热更新\nextraWatchFiles: [\".vuepress/*.ts\", \".vuepress/sidebars/*.ts\"],\n```\n\n\n\n#### 5、Markdown 配置\n\nVuePress 的基本功能就是把我们写的 Markdown 文件渲染成网站，我们可以在 `markdown` 配置中自定义网站的渲染规则，比如显示代码块的行号、支持更细层级的标题渲染等：\n\n```javascript\nmarkdown: {\n  // 开启代码块的行号\n  lineNumbers: true,\n  // 支持 4 级以上的标题渲染\n  extractHeaders: [\"h2\", \"h3\", \"h4\", \"h5\", \"h6\"],\n},\n```\n\n\n\n### 四、主题配置\n\n这里我使用的是 VuePress 默认主题，因为更精简、更稳定。\n\n> 官网默认主题配置：https://vuepress.vuejs.org/zh/theme/default-theme-config.html\n\n\n\n也有同学推荐 Hope 主题，其实我以前有的文档网站就是用的它，但后面觉得界面有点复杂了，个人还是喜欢最精简的哈哈。\n\n想修改主题配置，只需要更改 `config.ts` 配置文件中的 `themeConfig` 配置即可。\n\n```javascript\nexport default defineConfig({\n\t...\n    \n  // 主题配置\n  themeConfig: {\n    logo: \"/logo.png\",\n    nav: navbar,\n    sidebar,\n    lastUpdated: \"最近更新\",\n\n    // GitHub 仓库位置\n    repo: \"liyupi/codefather\",\n    docsBranch: \"master\",\n\n    // 编辑链接\n    editLinks: true,\n    editLinkText: \"完善页面\",\n\n    // @ts-ignore\n    // 底部版权信息\n    footer,\n    // 额外右侧边栏\n    extraSideBar,\n  },\n});\n```\n\n\n\n#### 1、主题基本配置\n\n包括整个网站的 Logo、GitHub 仓库的基本信息、页面底部展示最近更新时间、页面底部展示编辑文章链接等。\n\n配置如下：\n\n```javascript\nexport default defineConfig({\n\t...\n    \n  // 主题配置\n  themeConfig: {\n    // 替换 logo\n    logo: \"/logo.png\",\n      \n    // 页面底部展示最近更新时间\n    lastUpdated: \"最近更新\",\n      \n    // GitHub 仓库和分支信息\n    repo: \"liyupi/codefather\",\n    docsBranch: \"master\",\n      \n    // 页面底部展示编辑文章\n    editLinks: true,\n    editLinkText: \"完善页面\",\n  },\n});\n```\n\n\n\n#### 2、导航栏配置\n\n由于导航栏配置可能比较复杂，为了让配置更清晰，我们可以集中把导航配置写在 `navbar.ts` 文件中。\n\n如下图：\n\n![](https://pic.yupi.icu/1/1701831963654-4bcf32d3-e36f-4abd-bdc7-24adad7a621d.png)\n\n\n\n然后在 `config.ts` 的主题配置中引用 `navbar` 即可：\n\n```javascript\nimport navbar from \"./navbar\";\n\nexport default defineConfig({\n  // 主题配置\n  themeConfig: {\n    nav: navbar,\n  },\n});\n```\n\n\n\n可以参考官方文档的语法，添加导航栏配置，支持子导航栏。\n\n导航栏配置文档：[https://vuepress.vuejs.org/zh/theme/default-theme-config.html#%E5%AF%BC%E8%88%AA%E6%A0%8F](https://vuepress.vuejs.org/zh/theme/default-theme-config.html#导航栏)\n\n\n\n示例代码：\n\n```javascript\n// .vuepress/config.js\nmodule.exports = {\n  themeConfig: {\n    nav: [\n      {\n        text: 'Languages',\n        ariaLabel: 'Language Menu',\n        items: [\n          { text: 'Chinese', link: '/language/chinese/' },\n          { text: 'Japanese', link: '/language/japanese/' }\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701832229220-1a5f0c33-463e-4230-b2d7-62a39f9f1ff6.png)\n\n\n\n#### 3、侧边栏配置\n\n和导航栏一样，所有的侧边栏配置都放在 `sidebar.ts` 文件中，然后在 `config.ts` 中引用。\n\n但是由于侧边栏的配置比较复杂，文章多的时候需要分组、还要能自动识别文章中的小标题，所以这里我摸索出来的 **最佳实践** 是：\n\n1）将同类的文章放到同一个目录里，比如学习路线：\n\n![](https://pic.yupi.icu/1/1701832408501-84b15aeb-53c6-4c36-9e06-46016ff8fec9.png)\n\n\n\n2）将该目录的所有文章（侧边栏配置）集中写在单独的配置文件中，比如 `roadmapSideBar.ts`，放到 `sidebars` 目录下：\n\n![](https://pic.yupi.icu/1/1701832499136-0c9187f4-8da0-467f-8744-b9819e82899f.png)\n\n\n\n3）在侧边栏 `sidebar.ts` 配置中，引用各分类的侧边栏配置文件，实现不同分类下的文章，展示的侧边栏不同。\n\n```typescript\nimport {SidebarConfig4Multiple} from \"vuepress/config\";\n\nimport roadmapSideBar from \"./sidebars/roadmapSideBar\";\n// @ts-ignore\nexport default {\n    \"/学习路线/\": roadmapSideBar,\n    // 降级，默认根据文章标题渲染侧边栏\n    \"/\": \"auto\",\n} as SidebarConfig4Multiple;\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1697943889535-32cede40-9378-4b06-97c1-bc5648045f18.png)\n\n\n\n#### 4、底部配置\n\n这是我们自己使用 VuePress 自定义主题能力二次开发的功能，和导航栏、侧边栏配置一样，只用在 `footer.ts` 中填写配置，就能自动在网页底部生成友情链接、备案信息等，非常方便！\n示例代码如下：\n\n```javascript\n/**\n * 底部版权信息\n */\nexport default {\n  friendLinks: [\n    {\n      label: \"鱼鸢网络\",\n      href: \"https://yuyuanweb.com/\",\n    },\n    {\n      label: \"老鱼简历\",\n      href: \"https://www.laoyujianli.com/\",\n    },\n    {\n      label: \"编程学习圈\",\n      href: \"https://yupi.icu\",\n    },\n  ],\n  copyright: {\n    href: \"https://beian.miit.gov.cn/\",\n    name: \"沪ICP备19026706号-6\",\n  },\n};\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701832759044-127c6de2-e8d4-4349-aaf2-0d46cc582155.png)\n\n\n\n#### 5、右侧附加边栏配置\n\n这也是我们自己使用 VuePress 自定义主题能力二次开发的功能，和前面讲的配置一样，只用在 `extraSideBar.ts` 中填写配置，就能自动在网页右侧生成一个固定的侧边栏了，从而提供一些附加能力，比如对站长很重要的引流支持等。\n\n示例代码如下，支持自定义 HTML 代码：\n\n```javascript\n/**\n * 额外右侧边栏\n */\nexport default [\n  {\n    title: \"手机看\",\n    icon: \"/icon/mobile.png\",\n    popoverTitle: \"微信扫一扫\",\n    popoverUrl:\n      \"/qrcode-codefather.png\",\n    popoverDesc: \"可以手机看或分享至朋友圈\",\n  },\n  {\n    title: \"星球\",\n    icon: \"/icon/xingqiu.png\",\n    popoverTitle:\n      '<span style=\"font-size:0.8rem;font-weight:bold;\"><span style=\"color:red;\">保姆级实战项目教程</span>、编程学习指南、学习资源、求职指南、技术分享、编程交流</span>',\n    popoverUrl:\n      \"/qrcode-codenav.png\",\n    popoverDesc: \"知识星球：编程导航\",\n  },\n}\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701832927041-a9724d03-33c2-4121-8ddd-6ff055f3a6d3.png)\n\n\n\n### 五、插件配置\n\n除了上述基本能力外，我选择 VuePress 的主要原因就是它的插件生态特别好，随便下个插件，就能增强网站的能力。\n\n可以在 awesome-vuepress 项目中看到大量的插件，点进去就能看到插件的介绍、安装方式等。\n\n>  指路：https://github.com/vuepressjs/awesome-vuepress#plugins\n\n\n\n![](https://pic.yupi.icu/1/1701833393252-b2fa2cce-34fb-4401-841e-40055ca48af0.png)\n\n\n\n但是大家也发现了，插件太多，反而不知道该用哪些了。。。一个个试也太费时间了！\n\n所以这里我帮大家做了减法，在模板中只保留了我认为有用的核心插件。\n\n分别介绍一下：\n\n\n\n#### 1、返回顶部\n\n安装（其实模板中已经帮大家装好了）：\n\n```bash\nyarn add -D @vuepress/plugin-back-to-top\n# OR npm install -D @vuepress/plugin-back-to-top\n```\n\n\n\n开启插件配置，一行代码就能搞定：\n\n```javascript\nmodule.exports = {\n  plugins: ['@vuepress/back-to-top']\n}\n```\n\n\n\n#### 2、图片点击放大\n\n可以让网站中的所有图片支持点击放大功能。\n\n开启插件配置，一行代码就能搞定：\n\n```javascript\nmodule.exports = {\n  plugins: [\"@vuepress/medium-zoom\"]\n}\n```\n\n\n\n#### 3、SEO 相关插件\n\n安装插件后，只需要修改几行配置，就能让你的网站更容易被搜索引擎收录，从而提高访问量。\n\nSEO 相关插件有很多，列举几个我觉得不错的：\n\n\n\n1）谷歌分析\n\n是一款有利于谷歌搜索引擎优化的插件：\n\n```javascript\nmodule.exports = {\n  plugins: [\n    [\n      '@vuepress/google-analytics',\n      {\n        'ga': '' // 补充自己的谷歌分析 ID，比如 UA-00000000-0\n      }\n    ]\n  ]\n}\n```\n\n\n\n2）vuepress-plugin-seo\n\n\n\n作用是可以自定义生成的网站 meta 标签内容，比如把文章描述、标签信息放到标签中，从而增加收录率。\n\n> 插件官方：https://github.com/lorisleiva/vuepress-plugin-seo\n\n\n\n示例代码：\n\n```javascript\n// 定义常量\nconst author = \"程序员鱼皮\";\nconst domain = \"https://codefather.cn\";\nconst tags = [\"程序员\", \"编程\", \"计算机\"];\n\n// https://github.com/lorisleiva/vuepress-plugin-seo\n[\n  \"seo\",\n  {\n    siteTitle: (_, $site) => $site.title,\n    title: ($page) => $page.title,\n    description: ($page) =>\n      $page.frontmatter.description || $page.description,\n    author: (_, $site) => $site.themeConfig.author || author,\n    tags: ($page) => $page.frontmatter.tags || tags,\n    type: ($page) => \"article\",\n    url: (_, $site, path) =>\n      ($site.themeConfig.domain || domain || \"\") + path,\n    image: ($page, $site) =>\n      $page.frontmatter.image &&\n      (($site.themeConfig.domain &&\n        !$page.frontmatter.image.startsWith(\"http\")) ||\n        \"\") + $page.frontmatter.image,\n    publishedAt: ($page) =>\n      $page.frontmatter.date && new Date($page.frontmatter.date),\n    modifiedAt: ($page) => $page.lastUpdated && new Date($page.lastUpdated),\n  },\n],\n```\n\n\n\n3）sitemap 插件\n\n可以自动给网站生成 `sitemap.xml` 站点地图，让搜索引擎更了解你的网站。\n\n> 插件官方：https://github.com/ekoeryanto/vuepress-plugin-sitemap\n\n\n\n配置代码如下：\n\n```javascript\n// https://github.com/ekoeryanto/vuepress-plugin-sitemap\n[\n  \"sitemap\",\n  {\n    hostname: domain,\n  },\n],\n```\n\n\n\n4）自动推送到百度插件\n\n除了被动等待搜索引擎收录文章外，我们也可以主动给搜索引擎推送文章，提高收录率。\n\n使用这个插件，文章就会定期、自动地推送给百度，非常方便。\n\n> 插件官方：https://github.com/IOriens/vuepress-plugin-baidu-autopush\n\n\n\n配置代码如下：\n\n```js\n// https://github.com/IOriens/vuepress-plugin-baidu-autopush\n[\n  'vuepress-plugin-baidu-autopush'\n]\n```\n\n\n\n#### 4、支持代码复制\n\n这个插件对程序员来说可太实用了，只需一行配置，用户就能一键复制网站上的代码块：\n\n![](https://pic.yupi.icu/1/1701834155760-4192014f-168f-4a8c-aa4a-d9315cac3c73.png)\n\n\n\n配置代码如下：\n\n```js\n// https://github.com/znicholasbrown/vuepress-plugin-code-copy\n[\n  \"vuepress-plugin-code-copy\",\n  {\n    successText: \"代码已复制\",\n  },\n],\n```\n\n\n\n#### 5、配置 RSS 订阅\n\nRSS 是一种统一的内容更新标准，使用这个插件，可以让更多用户通过 RSS 订阅的方式查看到你网站的内容，从而增加访问量。\n\n> 插件官方：https://github.com/webmasterish/vuepress-plugin-feed\n\n\n\n配置代码如下：\n\n```js\n// https://github.com/webmasterish/vuepress-plugin-feed\n[\n  \"feed\",\n  {\n    canonical_base: domain,\n    count: 10000,\n    // 需要自动推送的文档目录\n    posts_directories: [],\n  },\n],\n```\n\n\n\n#### 6、**显示文章标签插件**\n\n> 插件官方：https://github.com/zq99299/vuepress-plugin/tree/master/vuepress-plugin-tags\n\n\n\n这个插件其实可有可无，允许你用 Markdown 的 FrontMatter 语法定义标签，然后在网站上展示。\n\n比如在某篇文章开头定义了如下代码：\n\n![](https://pic.yupi.icu/1/1701834439173-809fcc5a-771d-4138-8238-574ff741bc87.png)\n\n\n\n一行代码就能开启配置了：\n\n```js\n// https://github.com/zq99299/vuepress-plugin/tree/master/vuepress-plugin-tags\n[\"vuepress-plugin-tags\"],\n```\n\n\n\n然后就能看到如下效果：\n\n![](https://pic.yupi.icu/1/1701834618561-8a005ce0-282a-4878-904c-8b740d5671c7.png)\n\n\n\n\n\n#### 7、图片懒加载\n\n插件官方：https://github.com/tolking/vuepress-plugin--lazy\n\n\n\n最后这个插件我觉得最有用，只需要一行代码配置：\n\n```js\n['-lazy']\n```\n\n\n\n就能给网站所有的图片添加懒加载功能，当页面滚动到图片位置时才会请求加载图片，对于图片较多的网站来说，大幅提高加载速度、节约带宽。\n\n\n\n\n\n### 六、项目部署\n\n最后，我们要进行项目部署，也就是发到服务器上供别人访问。\n\nVuePress 的部署非常简单，首先在 `package.json` 文件中执行 `docs:build` 打包命令：\n\n![](https://pic.yupi.icu/1/1701834863289-d27beba6-8038-47d7-b047-f41982cbe7cf.png)\n\n\n\n打包成功，可以看到 `.vuepress` 目录下多了个 `dist` 目录，所有生成的网页资源都在该目录下：\n\n![](https://pic.yupi.icu/1/1701834892931-d583c19b-f357-4309-a2f7-58f78e6e4e57.png)\n\n\n\n接下来，我们只需要把 `dist` 目录下所有的文件，扔到服务器上就可以了。我之前已经给大家分享了好几种不同的项目上线方式，感兴趣的同学可以翻翻我之前的视频，这里就不重复演示了。\n\n![](https://pic.yupi.icu/1/WX20231206-144059@2x.png)\n\n\n\n## 最后\n\n通过这个教程，我相信大家不仅学到了文档网站的制作方法，还收获了很多其他的前端小知识，比如 SEO、懒加载之类的，希望对大家有帮助，都能做出自己的文档网站来沉淀分享知识。\n\n学会的话点赞收藏支持下啦，谢谢大家~",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/dZmeree6-640 (5).png",
        "language": null,
        "viewNum": 26,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-12T11:18:58.000+00:00",
        "updateTime": "2024-01-15T06:24:56.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3020,
          "coin": 170,
          "followeeNum": 1333,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2024-01-14T14:59:34.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1745761482102022146",
        "title": "Springboot项目中快速引入Rabbit MQ通用做法",
        "description": "本篇是在做BI项目时尝试引入MQ来优化项目时发现，MQ引入到项目中做法比较类似。变的只是谁发消息给谁，谁去监听消息。至于MQ的可靠性（比如生产者可靠性、消费者可靠性、消息可靠性）都是通过固定参数进行配置。 因此将引入MQ到BI项目的过程抽象出来，变成通用的方法～",
        "content": "# ⭐由来\n\n本篇是在做BI项目时尝试引入MQ来优化项目时发现，MQ引入到项目中做法比较类似。变的只是谁发消息给谁，谁去监听消息。至于MQ的可靠性（比如生产者可靠性、消费者可靠性、消息可靠性）都是通过固定参数进行配置。<br />因此将引入MQ到BI项目的过程抽象出来，变成通用的方法～\n\n# \uD83D\uDD36引入MQ目的\n\n砍掉耗时久的业务，缩短单个业务时间，监听者异步执行耗时久任务<br />做完之后，你可以完成springboot项目中MQ基本配置，并且MQ具有一定可靠性~\uD83D\uDE00\n\n# ⭕步骤\n\n1. 在Application中配置MQ\n\t1. 生产者确认机制，重连机制、消费者能者多劳、确认机制、失败消息处理策略\n\t2. 保证可靠性（配备了生产者确认，重连、消费者能者多劳，确认机制，失败消息处理策略） \n\n_**注意：不清楚的建议学习后配置，不要直接复制，按需设置~**_\n\n```xml\nspring:\n\trabbitmq:\n\t  # 连接信息\n\t  host: xxx # 你的IP地址\n\t  port: 5672\n  \t# 用户相关信息建议在rabbitMQ中设置好\n\t  virtual-host: /bi # 可在UI界面创建独属项目的虚拟机与用户名\n\t  username: xxx # 用户名\n\t  password: xxx # 密码\n\t  connection-timeout: 200ms # max waited time\n\t\n\t  # 生产者（消息发送者）\n\t  # 生产者确认机制 - 默认取消，消耗性能\n\t  publisher-confirm-type: none\n\t  publisher-returns: false\n\t  template:\n\t    # 生产者重连机制\n\t    retry:\n\t      enabled: true\n\t      initial-interval: 1000ms\n\t      multiplier: 1\n\t      max-attempts: 3\n\t\n\t  # 消费者（监听者）\n\t  listener:\n\t    simple:\n\t      prefetch: 1 # （能者多劳）每次只能获取一条信息，处理完才能获取下一条\n\t      acknowledge-mode: auto # 消费者确认 - 自动模式\n\t      retry:\n\t        enabled: true # 失败消息处理策略\n```\n\n```java\n/**\n * 失败者消息处理策略实现\n */\n@Bean\npublic MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){\n    return new RepublishMessageRecoverer(rabbitTemplate, BI_ERROR_EXCHANGE, BI_ERROR_ROUTING_KEY);\n}\n```\n\n2. 统一确定并定义业务的有关MQ常量 `MQConstant.java`\n\t1. 交换机、队列、Key\n\t2. error交换机，队列，Key（_按需设置_）\n3. 开始初始化\n\t1. 业务MQ 与 error交换机MQ，并绑定关系（选一个就行，推荐第二种）\n\n```java\n@Configuration\npublic class ErrorConfiguration {\n\n    @Bean\n    public Queue errorQueue() {\n        return QueueBuilder.durable(BI_ERROR_QUEUE).build();\n    }\n\n    @Bean\n    public DirectExchange errorExchange() {\n        return ExchangeBuilder.directExchange(BI_ERROR_EXCHANGE).build();\n    }\n\n    @Bean\n    public Binding errorBinding() {\n        return BindingBuilder.bind(errorQueue()).to(errorExchange()).with(BI_ERROR_ROUTING_KEY);\n    }\n\n}\n```\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n        // 队列：\n        // name - 队列名字\n        // durable - 队列持久化，不会随着MQ关闭而消失\n        // arguments：使队列为Lazy queue将消息尽快写入磁盘\n        value = @Queue(\n                name = BI_QUEUE_NAME,\n                durable = \"true\",\n                arguments = @Argument(name = \"x-queue-mode\", value = \"lazy\")),\n        // 交换机:指定交换机的名字与类型(默认direct)\n        exchange = @Exchange(name = BI_EXCHANGE_NAME, type = ExchangeTypes.DIRECT),\n        // 按交换机类型(Direct、Topic),设置Key\n        key = BI_ROUTING_KEY\n))\npublic void receiveMessage(String msg) {\n```\n\n\n      2. JSON消息转换器（替换掉原生的JDK）\n\n\n```java\n/**\n * 消息转换器\n * @return\n */\n@Bean\npublic MessageConverter messageConverter(){\n    return new Jackson2JsonMessageConverter();\n}\n```\n\n3. 编写业务代码（根据实际业务）\n\t1. 发送信息：砍掉耗时久的业务，变成发送消息\n\t\t1. 选用唯一性的信息，如id\n\t\t2. 确定好消息的数据类型\n\t2. 监听信息：添加监听者，执行耗时久的业务。\n\t\t1. 需要根据实际情况修改代码\n\t\t2. 可以根据业务实际情况使：**业务幂等性**\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n        // 队列：\n        // name - 队列名字\n        // durable - 队列持久化，不会随着MQ关闭而消失\n        // arguments：使队列为Lazy queue将消息尽快写入磁盘\n        value = @Queue(\n                name = BI_QUEUE_NAME,\n                durable = \"true\",\n                arguments = @Argument(name = \"x-queue-mode\", value = \"lazy\")),\n        // 交换机:指定交换机的名字与类型(默认direct)\n        exchange = @Exchange(name = BI_EXCHANGE_NAME, type = ExchangeTypes.DIRECT),\n        // 按交换机类型(Direct、Topic),设置Key\n        key = BI_ROUTING_KEY\n))\npublic void receiveMessage(Long chatId) {\n    // 0. 业务幂等性判断 - 基于乐观锁改造\n    boolean update = chartService.lambdaUpdate()\n            .set(Chart::getStatus, RUNNING_STATUS)\n            .eq(Chart::getId, chatId)\n            .eq(Chart::getStatus, WAIT_STATUS)\n            .update();\n    if (!update) {\n        handleChartUpdateError(chatId, \"该图表正在生成中！请耐心等待\");\n        return;\n    }\n```\n\n当然，还可以对其进行拓展，比如对error队列进行监听，针对错误消息进行特殊业务处理等等~<br />至此之后，MQ基本操作以及配置完毕~并且MQ可靠性相对高。\n\n最后，希望对你有用~",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 7,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1627854772813975553",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-12T10:55:46.000+00:00",
        "updateTime": "2024-01-15T02:21:09.000+00:00",
        "user": {
          "id": "1627854772813975553",
          "planetCode": "18055",
          "userName": "小何同学",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/pSUPib7O88l3Xe43fThm8miaKzCRRjc1bkNzHQbTCAWgQEIL9ORdaFw2rp9d3mTxyHGoKR2Ex1QiaVUia4sZhel4ZQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-02-17T10:47:58.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-21T02:16:36.000+00:00",
          "updateTime": "2024-01-12T10:53:08.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1745075867219927042",
        "title": "一篇文章弄懂Lambda表达式",
        "description": null,
        "content": "# Lambda\n\n## Lambda简介\n\nLambda表达式是`Java8`引入的一个重要特性，相当于一个语法糖。\n\n> 语法糖（Syntactic sugar）是指在编程语言中引入的一种语法，它可以使代码更易读、更简洁，但并没有引入新的功能或改变语言的底层机制。语法糖并不会改变语言的语义，只是提供了一种更方便的编写方式。\n\n* Lambda表达式可以被视为**匿名函数**\n* 允许在**需要函数**的地方以**更简洁的方式定义功能**\n\n**使用条件：**只要是**函数式接口**就可以用Lambda表达式简化\n\n> 函数式接口：接口中有且只有一个未实现的方法，这个接口就叫函数式接口\n\n如果接口中有超过一个未实现方法，则不是函数式接口，不能用Lambda表达式\n如果接口中有一个未实现方法，有一个默认实现方法，则是函数式接口，可以用Lambda表达式\n\n如：\n\n```\n// 接口中有超过一个未实现方法,不是函数式接口\ninterface MyInterface {\n    int sum(int a, int b);\n    int min(int a, int b);\n}\n\n// 接口中只有一个未实现的方法,是函数式接口\ninterface MyCase{\n    int hello();\n    default int hello(int a){return a;} //默认实现\n}\n```\n\n可以用`jdk`中提供的检查注解`@FunctionalInterface`来检查该接口是否为函数式接口\n\n正常情况：\n\n<img src=\"https://img.pidanxia.ink/image/202401100036334.png\" alt=\"image-20240109160929223\" style=\"zoom:80%;\" />\n\n异常情况：<img src=\"https://img.pidanxia.ink/image/202401100036307.png\" alt=\"image-20240109160954618\" style=\"zoom:80%;\" />\n\n---\n\n\n\n## Lambda表达式与函数式接口\n\n举个例子：\n\n有一个接口`MyInterface`，里面有一个方法`sum()`。\n\n```\ninterface MyInterface {\n    int sum(int a, int b);\n}\n```\n\n如果想要实现这个接口，我们可以使用两种方法。\n\n1. 自己写实现类\n\n   ```\n   class MyInterfaceImpl implements MyInterface {\n       @Override\n       public int sum(int a, int b) {\n           return a + b;\n       }\n   }\n   ```\n\n   然后调用\n\n   ```\n   public class Lambda {\n       public static void main(String[] args) {\n           MyInterface myInterface = new MyInterfaceImpl();\n           int result = myInterface.sum(1, 2);\n           System.out.println(result);\n       }\n   }\n   ```\n\n2. 创建匿名实现类\n\n   如果每个接口都要写实现类的话，总觉得会有点麻烦。\n\n   而且，如果在以后的业务中，要实现的方法不是两数之和，而是两数的平方和的话，那我岂不是要再写一个实现类？\n\n   为了解决这个问题，我们可以采用[匿名实现类](https://pidanxia.ink/inner-class/)，**动态的**去实现接口。\n\n   ```\n   public class Lambda {\n       public static void main(String[] args) {\n   \n           // 1. 自己创建实现类对象\n           MyInterface myInterface = new MyInterfaceImpl();\n           int result = myInterface.sum(1, 2);\n           System.out.println(\"我是 自己创建的实现类对象 \" + result);\n   \n           // 2. 创建匿名实现类\n           MyInterface myInterface1 = new MyInterface() {\n               @Override\n               public int sum(int a, int b) {\n                   return a*a + b*b;\n               }\n           };\n           int result1 = myInterface1.sum(1, 2);\n           System.out.println(\"我是 匿名实现类 \" + result1);\n       }\n   }\n   ```\n\n   运行结果：![image-20240109115924448-1704792569563-1](https://img.pidanxia.ink/image/202401100037364.png)\n\n可以看到，每次创建匿名实现类的时候，有很多格式上的东西是每次都要写的，这样就很冗余。比如下面我选中的这部分：\n\n![image-20240109150517900-1704792569563-2](https://img.pidanxia.ink/image/202401100036273.png)\n\n这部分在上面的接口`interface MyInterface`中就已经定死了。就算不写`new MyInterface()`，从创建匿名实现类的前面部分**MyInterface** myInterface1，也可以看出实现的就是`MyInterface`接口。\n\n与前面相比，lambda表达式只保留动态的东西，把写死的东西去掉。\n用lambda表达式的方式实现接口：\n\n```\n        // 3. Lambda表达式实现接口  参数列表 + 箭头 + 方法体\n        MyInterface myInterface2 = (int a, int b) -> {\n            return a * a + b * b;\n        };\n```\n\n这是lambda表达式的完整写法，然而我们可以看到，入参的类型在接口中也是定好的。这就说明还有更**简化的写法**：\n\n1. 参数类型可以不写，只写参数名，参数变量名随意定义\n\n   ```\n           MyInterface myInterface3 = (x, y) -> {\n               return  x * x + y * y;\n           };\n   ```\n\n   参数名不一定是接口中定义的`(a,b)`，也可以定义为其他的名字，比如`(x,y)`\n\n2. 参数部分在没有入参的时候，最少可以只有一个`()`，**但是不能不写括号！！！！**\n\n   或者在只有一个入参的时候，只有一个参数名\n\n   ```\n   interface MyCase{\n       int hello();\n   }\n   \n   public class Lambda {\n       public static void main(String[] args) {\n           MyCase myCase = () -> {\n               return 1;\n           };\n       }\n   }\n   ---------------------------------------------------\n   interface MyCase1{\n       int hello(int a);\n   }\n   \n   public class Lambda {\n       public static void main(String[] args) {\n           MyCase1 myCase1 = a -> {\n               return a + 1;\n           };\n       }\n   }\n   ```\n\n3. 方法体只有一句话的时候，`{}`和`return`可以省略\n\n   ```\n   interface MyCase1{\n       int hello(int a);\n   }\n   \n   public class Lambda {\n       public static void main(String[] args) {\n           MyCase1 myCase11  = a ->  a + 2;\n           // 调用方法\n           System.out.println(myCase11.hello(1));\n       }\n   }\n   ```\n\n---\n\n\n\n## Lambda表达式使用\n\n未来使用函数时接口会比较频繁，当调用某个方法传入参数，这个参数实例是一个接口对象，且只定义了一个方法，就可以直接用Lambda简化写法\n\n### 比较器的使用\n\n当我们使用比较器的时候，可以使用Lambda表达式简化写法\n\n```\npublic class Lambda {\n    public static void main(String[] args) {\n        ArrayList<String> names = new ArrayList<String>();\n        names.add(\"Pidanxia\");\n        names.add(\"Lucy\");\n        names.add(\"Bob\");\n        names.add(\"Tom\");\n        \n        // 普通写法\n        Collections.sort(names,new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return o1.compareTo(o2);\n            }\n        });\n        \n        // Lambda写法\n        Collections.sort(names,(o1,o2)->o1.compareTo(o2));\n    }\n}\n```\n\n可以看到Lambda表达式与普通写法相比，简洁了非常多。\n除了Lambda表达式之外，还可以用方法引用来简化写法。如：\n\n`Collections.sort(names, String::compareTo);`\n\n> 类::方法：表示引用类中的实例方法。\n>\n> 比如例子中的语句，就是说，以`names`为入参，调用`String类`中的`compareTo`方法\n\n### 线程的使用\n\n```\n        // 普通写法\n        new Thread(){\n            @Override\n            public void run() {\n                System.out.println(\"Hello\");\n            }\n        }.start();\n        // Lambda写法\n        new Thread(()->System.out.println(\"Hello\")).start();\n```\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 24,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 2,
        "priority": 0,
        "userId": "1674965546757525505",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-10T13:31:23.000+00:00",
        "updateTime": "2024-01-13T09:47:11.000+00:00",
        "user": {
          "id": "1674965546757525505",
          "planetCode": "23765",
          "userName": "无名",
          "userAvatar": null,
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-06-17T10:42:34.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-07-01T02:18:00.000+00:00",
          "updateTime": "2023-12-06T08:58:35.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1745052382141620226",
        "title": "从小公司到大厂，重点都考什么？",
        "description": null,
        "content": "大家好，我是鱼皮，今天 [编程导航](https://mp.weixin.qq.com/s/eNjauC-3361z-l7fy3VssA) 的鱼友问了我一个很不错的求职问题，大概是下面这样：\n\n> 我是一年工作经验小公司后端，我该怎样准备去向中大厂跳槽？\n\n\n\n想要知道如何准备跳槽到中大厂，我们就要了解小公司、中厂和大厂的求职考察重点。个人观点，仅供参考！\n\n一般来说，小公司最注重实践能力，即 **你能不能干活** ，关注求职者的 **下限** 。很多时候要求并不高，你能用开发框架写代码基本就行了。\n\n所以简历上有实际上线的项目经历是格外加分的，面试时也会重点考察你的项目经历。当然，凡事不绝对，也有老板不懂技术的小公司，就喜欢到网上找点八股文，然后像考试一样机械地考察你。\n\n中厂的要求会有所提高，不仅会注重实践能力，同时还会关注你的基础和可培养性。\n\n所以投递中厂，简历上不仅要有编程开发相关的技术栈，还要有算法数据结构、计算机网络等计算机基础相关的内容。中厂的面试一般来说会有算法题目、八股文的基本功考察，也会有项目经历的考察。\n\n想要进大厂，难度就直接指数级上升了。大厂除了注重实践能力、基本功之外，还会关注候选人的自主性和潜能，保证候选人未来能够推动事情的发展并应对种种挑战。不仅关注求职者的下限，更关注 **上限** 。\n\n而且因为大家都想进大厂、投简历又没成本，所以竞争十分激烈，这才有了笔试和学历的种种门槛。所以想进大厂，你要通过一切办法在简历上给自己贴金，各种竞赛奖项、实习科研经历、各种光环等等，都能快速证明你的能力和自主性，让你在众多简历中脱颖而出。\n\n有的时候你可能以为自己很优秀，八股文背得贼 6、面试过程也很顺利。但为什么最终没有拿到 offer 呢？可能就是因为你的竞争者的能力上限比你高。\n\n大厂面试除了考察八股文、几道算法题目和项目经历外，一般还会有业务场景设计问题、甚至是行业问题。\n\n举几个例子，都是我当年被问到的：\n\n1. 腾讯实习：如何设计短链系统？\n2. 字节实习：如何设计一个实时弹幕系统？\n3. 字节校招：如何设计地铁轨道调通系统？\n\n\n\n此外，大厂招人会更谨慎。尤其对校招来说，因为能力很强的人很多，宁可漏掉一个人才也不希望错招，不然搞不好就出个删库跑路的招聘事故。所以大厂招聘流程中，可能还会让你做性格测试、综合素质测评，并且会进行严格的背调。所以投递大厂就千万不要简历造假，被查出来可能会拉进黑名单。\n\n\n\n对社招跳槽来说，有一个很大的加分技巧，就是去投递和你之前的工作经历业务相似的公司。因为你之前有这方面的经验，很多术语或者很多业务特定的知识你基本都是理解的。这样相比于其他没有做过此类业务的同学来讲，你的竞争力会更大，找工作也会更轻松一些。\n\n此外，如果实在没办法一步跳槽到中大厂，那就持续跳槽、不断涨薪，一级级往上走就好了。来日方长，我们需要不断学习，持续成长。\n\n建议大家完整观看下我分享的几个工作中提升的方法： https://b23.tv/6BwjNz5\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/egPoUK9o-640 (8).jpeg",
        "language": null,
        "viewNum": 33,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-10T11:58:04.000+00:00",
        "updateTime": "2024-01-15T04:33:46.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3020,
          "coin": 170,
          "followeeNum": 1333,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2024-01-14T14:59:34.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1744041756367790081",
        "title": "markdown文本解析成html，并生成大纲",
        "description": "markdown文本解析成html，并生成大纲",
        "content": "markdown转换成html参考：[https://blog.csdn.net/weixin_45894305/article/details/106362783?spm=1001.2014.3001.5506](https://blog.csdn.net/weixin_45894305/article/details/106362783?spm=1001.2014.3001.5506)\n\n### 渲染后样式跟预期不符\n添加css即可，一般直接在父标签上设定一个类名然后给子标签加样式：\n可以在github上找一个用：[https://github.com/sindresorhus/github-markdown-css](https://github.com/sindresorhus/github-markdown-css)\n\n### 转换成html无法通过js操作\n这是因为转换后dom加载需要一定的时间，在这个时间内操作会出现 null 问题，解决：\n```go\nsetTimeout(() => {\n      //要处理转换html后的逻辑\n  },1)\n```\n一般参数1毫秒即可，最好设大一点\n\n### 生成大纲\n#### 拿到所有子标签\n当dom渲染上去后，我们去获取到用于渲染html文本的标签的所有子标签\n```go\ndocument.querySelector(\".markdown-body\").children\n```\n#### 通过正则表达式提取出h1-h10之间的标签\n```go\nconst regex =  /h(10|[1-9])/g;\n      for (let i = 0; i < document.querySelector(\".markdown-body\").children.length; i++){\n        if (htmlContent[i].localName.match(regex)) {\n            \n        }\n}\n```\n#### 处理每个标题\n大纲一般都有父子关系，我们需要去对每个标题进行父子关系的处理，比如标题 3 在标题 1 的后面，那他就是标题 1 的子标题\n```go\nconst  treeData = ref([]);\n//是否找到子目录\nlet isFind = false;\n//解析子目录\nconst setSubDirectory = (directory, level, label) => {\n  //表示当前的目录层级\n  const curr = directory\n  //表示递归的目录层级\n  const children = directory.children\n  if (children.length > 0) {\n    //递归子目录，从最后一个孩子开始\n    setSubDirectory(directory.children[children.length-1],level,label)\n  }\n  //子目录已经归位\n  if (isFind === true) return;\n  //当前层级小于等于目录层级，表示找到了目录\n  if (curr.level < level) {\n    isFind = true\n    curr.children.push({ level, label,children: []})\n  }\n}\n\n//解析html，生成目录树\nconst setTreeDataByHtml = (htmlContent) => {\n  const regex =  /h(10|[1-9])/g;\n      for (let i = 0; i < htmlContent.length; i++){\n        if (htmlContent[i].localName.match(regex)) {\n          const level = parseInt(htmlContent[i].localName.replace(\"h\", \"\"))\n          const label = htmlContent[i].innerText\n          //不需要找子目录\n          if (treeData.value.length === 0 || treeData.value[treeData.value.length - 1].level >= level) {\n              treeData.value.push({ label, level,children: []})\n          } else {\n            isFind = false\n            setSubDirectory(treeData.value[treeData.value.length - 1],level,label)\n          } \n        }\n}\n}\n```\n> 细节：我们将标题分为两类，一种是直接可以用作父标题，一种则是需要添加在父标题中的子标题\n> 如果当前标题的层级小于等于数据中最后一个父标题的层级，那么他就是父标题，直接添加到数组中即可\n> 子标题通过递归的方式，先找到最底层的标题，依次往上寻找，直到找到合适的位置即可\n> 合适的位置：子标题的层级大于父标题的层级，这里我们用level来表示\n\n#### 解析生成大纲\n通过 element-plus 中的 tree组件库来实现\n#### 测试结果\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/38666573/1704479281260-c0c0faf7-ea98-4ca8-a9e7-949882daf848.png#averageHue=%23cddacc&clientId=u26c5aec5-67b1-4&from=paste&height=932&id=u5feaf72a&originHeight=932&originWidth=1877&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1230008&status=done&style=none&taskId=u2c716e12-dc85-4ca8-b7fd-23d955ae337&title=&width=1877)\n#### 完整代码\n> tips:  复制过去记得改，是拿以前项目写的\n\n文章详情页，在此引用大纲页面，为   ArticleTree，调用 ArticleTree 里的函数生成大纲的函数在82行\n```go\n<template>\n  <div class=\"container view\">\n    <div class=\"card\">\n      <div class=\"card-body\">\n        <h3>{{ share.title }}</h3>\n        <span class=\"author_descibe\" style=\"margin-left: 0px\">作者：</span>\n        <router-link class=\"ToOpenShare\" :to=\"{ name: 'home' }\">\n          <img :src=\"share.authorPhoto\" alt=\"\" />\n          <span class=\"author\" style=\"font-size: 18px; margin-left: 10px\"\n            >{{ share.author }}\n          </span>\n        </router-link>\n        <span class=\"createtime\">{{ share.createtime }}</span>\n        <span class=\"reading_descibe\">阅读</span>\n        <span class=\"reading\">{{ share.reading }}</span>\n        <hr />\n\n        <div v-html=\"share.content\" class=\"markdown-body\"></div>\n      </div>\n    </div>\n\n    <hr />\n\n    <CommentView :shareId=\"route.params.shareId\" />\n  </div>\n <ArticleTree ref=\"ArticleTreeRef\"/> \n</template>\n\n<script>\nimport $ from \"jquery\";\nimport { useRoute } from \"vue-router\";\nimport { useStore } from \"vuex\";\nimport { reactive, onMounted,ref } from \"vue\";\nimport CommentView from \"@/views/share/comment/CommentView.vue\";\nimport { marked } from 'marked';\nimport ArticleTree from \"./ArticleTree.vue\";\n\nexport default {\n  components: {\n    CommentView,ArticleTree\n  },\n  setup() {\n    const store = useStore();\n    const route = useRoute();\n    const ArticleTreeRef = ref(null)\n    const share = reactive({\n      title: \"\",\n      createtime: \"\",\n      content: \"\",\n      reading: null,\n      authorPhoto: \"\",\n      author: \"\",\n    });\n    onMounted(() => {\n    const link = document.createElement('link')\n    link.type = 'text/css'\n    link.rel = 'stylesheet'\n    link.href = 'https://cdn.bootcss.com/github-markdown-css/2.10.0/github-markdown.min.css'\n    document.head.appendChild(link)\n});\n\n    \n    //打开某一分享页面就调用\n    const getShare = () => {\n      $.ajax({\n        url: \"https://app5608.acapp.acwing.com.cn/api/get/share/\",\n        type: \"get\",\n        data: {\n          userId: store.state.user.id,\n          shareId: route.params.shareId,\n        },\n        headers: {\n          Authorization: \"Bearer \" + store.state.user.token,\n        },\n\n        success(resp) {\n          // eslint-disable-next-line no-empty\n          if (resp.error_message === \"successfully\") {\n            share.title = resp.share.title;\n            share.createtime = resp.share.createTime;\n            share.content = marked(resp.share.content)\n            setTimeout(() => {\n      ArticleTreeRef.value.setTreeDataByHtml(document.querySelector(\".markdown-body\").children)\n  },1)\n            share.reading = resp.share.reading;\n            share.authorPhoto = resp.authorPhoto;\n            share.author = resp.author;\n          }\n        },\n        error() {},\n      });\n    };\n\n    getShare();\n\n    return {\n      share,\n      route,\n      ArticleTreeRef,\n    };\n  },\n};\n</script>\n\n<style scoped>\n.view {\n  margin-top: 20px;\n}\n\n.container {\n  max-width: 900px;\n}\nhr {\n  color: gray;\n}\nimg {\n  border-radius: 50%;\n  width: 4vh;\n  height: 4vh;\n  margin-left: 10px;\n  line-height: 15px;\n}\n\n.author_descibe,\n.createtime,\n.reading_descibe,\n.reading {\n  font-size: 12px;\n  color: gray;\n  margin-left: 10px;\n}\n\n.ToOpenShare {\n  color: rgb(51, 122, 199);\n  text-decoration: none;\n  line-height: 30px;\n  font-size: 16px;\n}\n\n.ToOpenShare:hover {\n  color: rgb(35, 82, 124);\n  text-decoration: underline;\n}\n</style>\n\n```\nArticleTree\n```go\n<!-- 将文章目录以树的形式展示 -->\n<template>\n  <el-tree :data=\"treeData\" :expand-on-click-node=\"false\" class=\"tree\"></el-tree>\n</template>\n\n<script setup>\nimport { ref,defineExpose } from \"vue\";\nconst  treeData = ref([]);\n//是否找到子目录\nlet isFind = false;\n//解析子目录\nconst setSubDirectory = (directory, level, label) => {\n  //表示当前的目录层级\n  const curr = directory\n  //表示递归的目录层级\n  const children = directory.children\n  if (children.length > 0) {\n    //递归子目录，同层级下，数组下标在其范围即可\n    setSubDirectory(directory.children[children.length-1],level,label)\n  }\n  //子目录已经归位\n  if (isFind === true) return;\n  //当前层级小于等于目录层级，表示找到了目录\n  if (curr.level < level) {\n    isFind = true\n    curr.children.push({ level, label,children: []})\n  }\n}\n\n//解析html，生成目录树\nconst setTreeDataByHtml = (htmlContent) => {\n  const regex =  /h(10|[1-9])/g;\n      for (let i = 0; i < htmlContent.length; i++){\n        if (htmlContent[i].localName.match(regex)) {\n          const level = parseInt(htmlContent[i].localName.replace(\"h\", \"\"))\n          const label = htmlContent[i].innerText\n          //不需要找子目录\n          if (treeData.value.length === 0 || treeData.value[treeData.value.length - 1].level >= level) {\n              treeData.value.push({ label, level,children: []})\n          } else {\n            isFind = false\n            setSubDirectory(treeData.value[treeData.value.length - 1],level,label)\n          } \n        }\n}\n}\ndefineExpose({\n  setTreeDataByHtml\n})\n</script>\n\n\n<style scoped>\n.tree{\n  width: 20%;\n  position: fixed;\n  top: 80px;  /* 从页面顶部的距离 */\n  right: 50px; /* 从页面左侧的距离 */\n}\n</style>\n```\n### 点击目录导航到对应标题位置\n只要获取到dom实例，通过scrollIntoView函数即可完成\n示例：\n```go\nelement.scrollIntoView({\n          behavior: \"instant\",\n          block: \"center\",\n        });\n```\n### 当滚动条滚动到标题位置，设置目录里标题高亮\n通过IntersectionObserver实例来做，当监听的dom出现在视图区域中，会触发回调函数，从而来设置高亮\n示例：\n```go\n// 创建 Intersection Observer 实例\nconst observer = new IntersectionObserver((entries) => {\n  entries.forEach((entry) => {\n    if (entry.isIntersecting) {\n      // 目标元素进入可视区域\n      treeRef.value.setCurrentKey(entry.target.id)\n    }\n  });\n}, { threshold: 0 });\n//将要监听的目标元素加入Observer中\nobserver.observe(htmlContent[i])\n```\n> htmlContent[i] 代表你要监听目标元素的dom\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 18,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1688498276585766913",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-01-07T17:02:12.000+00:00",
        "updateTime": "2024-01-14T13:12:45.000+00:00",
        "user": {
          "id": "1688498276585766913",
          "planetCode": "30885",
          "userName": "晨",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/hgPeicCHWgWQlJLO4qOtfOU7rzH6bnWMpiaspouH5u0k6EWhTibmcH2iaJiaLIMhn2bKibvKXSu4QUtI4yJia08ccNwUA/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-12-30T05:42:47.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-08-07T10:32:14.000+00:00",
          "updateTime": "2024-01-02T17:07:38.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "351",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "44"
  },
  "message": "ok"
}